package main

import (
	"context"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"encoding/json"

	"github.com/sashabaranov/go-openai"
)

var ignore_dirs = []string{".git", "libs", "tools"}
var toTranslate = []string{}

// Look for any string inside of a function call that looks like: L:G("string") or L:G('string')
var translationMatch = regexp.MustCompile(`L:G\(["'](.+?)["']\)`)

func removeDuplicates(elements []string) []string {
	encountered := map[string]bool{}
	result := []string{}
	for v := range elements {
		if encountered[elements[v]] {
			// Do not add duplicate.
		} else {
			encountered[elements[v]] = true
			result = append(result, elements[v])
		}
	}
	return result
}

func readFile(path string) error {
	f, err := os.Open(path)
	if err != nil {
		return err
	}
	defer f.Close()
	data, err := io.ReadAll(f)
	if err != nil {
		return err
	}
	matches := translationMatch.FindAllSubmatch(data, -1)
	for _, match := range matches {
		toTranslate = append(toTranslate, string(match[1]))
	}
	return nil
}

func toPtr[T any](v T) *T {
	return &v
}

func main() {
	err := filepath.Walk(".", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		for _, dir := range ignore_dirs {
			if strings.HasPrefix(path, dir) {
				return nil
			}
		}
		if !strings.HasSuffix(path, ".lua") {
			return nil
		}
		return readFile(path)
	})

	if err != nil {
		panic(err)
	}
	toTranslate = removeDuplicates(toTranslate)
	var inputs = make([]string, 30)
	var outputs []string
	for i, s := range toTranslate {
		inputs[i%30] += s + "\n"
	}

	key := os.Getenv("OPENAI_API_KEY")
	client := openai.NewClient(key)

	for i, input := range inputs {
		if input == "" {
			break
		}
		resp, err := client.CreateChatCompletion(
			context.Background(),
			openai.ChatCompletionRequest{
				Model: openai.GPT4o,
				Seed:  toPtr(8472),
				ResponseFormat: &openai.ChatCompletionResponseFormat{
					Type: openai.ChatCompletionResponseFormatTypeJSONObject,
				},
				Messages: []openai.ChatCompletionMessage{
					{
						Role: openai.ChatMessageRoleSystem,
						Content: `You are translation bot for World of Warcraft. You are to translate strings that are provided to you, one string per line,
							into the languages provided. You must keep in mind the context of World of Warcraft and translate the strings within the context
							of the game, taking care to understand the nuance of game specific lingo. All inputs are in American English.
							You are to output a JSON map with each key being input text. The value for each key is a JSON object, with a key for each language country code,
							and the translated string as the value for the given country code.
							The strings need to be translated into the following country codes:
							koKR - Korean
							frFR - French
							deDE - German
							zhCN - Chinese (Simplified)
							esES - Spanish (Spain)
							zhTW - Chinese (Traditional)
							esMX - Spanish (Mexico)
							ruRU - Russian
							ptBR - Portuguese (Brazil)
							itIT - Italian`,
					},
					{
						Role:    openai.ChatMessageRoleUser,
						Content: input,
					},
				},
			},
		)
		if err != nil {
			panic(err)
		}
		outputs = append(outputs, resp.Choices[0].Message.Content)
		fmt.Printf("Processed chunk %d (%d/%d)\n", i, i+1, len(inputs))
	}
	var luaOutput = `local addonName = ... ---@type string

---@class BetterBags: AceAddon
local addon = LibStub('AceAddon-3.0'):GetAddon(addonName)

---@class Localization: AceModule
local L = addon:GetModule('Localization')

--[[
	THIS FILE IS AUTOGENERATED. DO NOT EDIT THIS FILE DIRECTLY.
	IF YOU NEED TO MODIFY A TRANSLATION, PLEASE EDIT overrides.lua!
]]--

`
	for _, s := range outputs {
		var translations map[string]map[string]string
		fmt.Println(s)
		if err := json.Unmarshal([]byte(s), &translations); err != nil {
			panic(err)
		}
		for term, translation := range translations {
			luaOutput += fmt.Sprintf(`L.data["%s"] = {`, term) + "\n"
			for locale, text := range translation {
				luaOutput += fmt.Sprintf(`  ["%s"] = "%s",`, locale, text) + "\n"
			}
			luaOutput += "}\n"
		}
	}
	if err := os.WriteFile("core/translations.lua", []byte(luaOutput), 0644); err != nil {
		panic(err)
	}
}
